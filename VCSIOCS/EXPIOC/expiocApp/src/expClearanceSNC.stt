program expClearanceSNC

%{
/*******************************************************************/
#include "vcs_var_mes.h" // define this here so C functions are seen
/*******************************************************************/	
#define STOK       	0
#define B26ON		66 
#define B28bOFF		71
#define B28bON		77 
#define B28aOFF		70
#define B28aON		76
#define B27ON		75 
#define B27OFF		69
#define B29OFF		74  
#define DA12S1OFF	72
#define DA12S2OFF	73   
#define G10OFF		151
#define WFVC		55 
#define EXPPNK		20 
}%
/* Declare seq variables*/
short EXP_VC;   
short EXP_W26_STS;
short EXP_W28b_STS;
short EXP_W28a_STS;
short EXP_W27_STS;
short EXP_W29_STS;
short EXP_PNK;
short EXP_RST_OUTS;
short EXP_G10_STS;
short EXP_FAIL_COND;
short EXP_OLD_FAIL_COND;
string EXP_CLR_STATS; 
string EXP_INTLCK_STATS;
short exp_failed_rst = FALSE;
short exp_not_cleared = FALSE;

/* Associate SNL variables with epics output pv's*/
assign	EXP_CLR_STATS		to	"{SYS}:EXP-CLR-STATS"; 
assign	EXP_INTLCK_STATS	to	"{SYS}:EXP-INTLCK-STATS"; 
assign 	EXP_VC 				to 	"{SYS}:EXP-VC"; 
/* Associate SNL variables with epics input pv's*/
assign	EXP_RST_OUTS		to	"{SYS}:RST-EXP"; 
assign 	EXP_W26_STS 		to 	"{SYS}:EXP-W26-STS"; 
assign 	EXP_W28b_STS 		to  "{SYS}:EXP-W28b-STS";   
assign 	EXP_W28a_STS 		to 	"{SYS}:EXP-W28a-STS";
assign 	EXP_W27_STS 		to 	"{SYS}:EXP-W27-STS";
assign	EXP_W29_STS			to	"{SYS}:EXP-W29-STS";
assign	EXP_FAIL_COND		to	"{SYS}:EXP-FAIL-COND";
assign	EXP_PNK		        to	"{SYS}:EXP-PNK";
assign	EXP_G10_STS			to	"{SYS}:EXP-G10-STS";

monitor	EXP_VC;
monitor EXP_W26_STS; 
monitor EXP_W28b_STS;   
monitor EXP_W28a_STS;
monitor EXP_W27_STS;
monitor	EXP_W29_STS;
monitor	EXP_FAIL_COND;
monitor	EXP_PNK;
monitor	EXP_G10_STS;

ss EXP_clearance_status {
    state init {
		when (delay(1)) {
			initVault();
			printf("%sEXPERIMENTAL VAULT INITIALISATION COMPLETED%s\n",OK,DEF);
		} state watchman_26_pressed	
    }
//////////////////////////////////////////////////////////

	state watchman_26_pressed {

		when (EXP_FAIL_COND != STOK) {
			EXP_OLD_FAIL_COND = EXP_FAIL_COND;
		} state  clearance_faillures
        
		when (EXP_W26_STS == WFVC) {

		} state  clearance_pending       
			
		when (EXP_W26_STS == B26ON) {
			EXP_clear_underway();
			EXP_update_report(B26ON);
		} state watchman_26_released
	}
//////////////////////////////////////////////////////////
	state clearance_pending {
		option -e;
		option -x;
   
		entry {
			resetVault();
			EXP_update_report(WFVC);
			exp_not_cleared = TRUE; // we use this to command user to start or restart vault clearance
		}
   
		when (EXP_W26_STS != WFVC) {

		} state watchman_26_pressed  		

	}
//////////////////////////////////////////////////////////
	state watchman_26_released {
		
		when (EXP_FAIL_COND != STOK) {

		} state  clearance_faillures
			
		when (EXP_W26_STS != B26ON) {
			EXP_update_report(G10OFF);
		} state gate_g10_closed
	}
//////////////////////////////////////////////////////////
	state gate_g10_closed {
		
		when (EXP_FAIL_COND != STOK) {

		} state  clearance_faillures
		
		when (!EXP_G10_STS) {
			EXP_update_report(B28bOFF);
		} state watchman_28b_pressed
	}
//////////////////////////////////////////////////////////
	state watchman_28b_pressed {

		when (EXP_FAIL_COND != STOK) {

		} state   clearance_faillures
		
		
		when (EXP_W28b_STS == B28bON) {
			EXP_update_report(B28bON);
		} state watchman_28b_released
	}
//////////////////////////////////////////////////////////
	state watchman_28b_released {
		
		when (EXP_FAIL_COND != STOK) {

		} state  clearance_faillures
			
		when (EXP_W28b_STS != B28bON) {
			EXP_update_report(B28aOFF);
		} state watchman_28a_pressed
		
	}
	
///////////////////////////////////////////////////////////
	state watchman_28a_pressed {
		
		when (EXP_FAIL_COND != STOK) {

		} state  clearance_faillures
		

		when (EXP_W28a_STS == B28aON) {
			EXP_update_report(B28aON);
		} state watchman_28a_released
	}
////////////////////////////////////////////////////////////
	state watchman_28a_released {

		when (EXP_FAIL_COND != STOK) {

		} state  clearance_faillures
			
	
		when (EXP_W28a_STS != B28aON) {
			EXP_update_report(B27OFF);
		} state watchman_27_pressed
	}
////////////////////////////////////////////////////////////
	state watchman_27_pressed {

		when (EXP_FAIL_COND != STOK) {

		} state  clearance_faillures
		
		
		when (EXP_W27_STS == B27ON) {
			EXP_update_report(B27ON);
		} state watchman_27_released
	}
/////////////////////////////////////////////////////////////
	state watchman_27_released {

		when (EXP_FAIL_COND != STOK) {

		} state  clearance_faillures
		
		when (EXP_W27_STS != B27ON) {
		} state A12_switch_I_closed		
	}
///////////////////////////////////////////////////////////
	state A12_switch_I_closed {
 
		option -e;

		entry {
		  EXP_update_report(DA12S1OFF);
		}  
		
		when (EXP_FAIL_COND != STOK) {

		} state  clearance_faillures
		
		when (EXP_W29_STS != DA12S1OFF) {			

		} state A12_switch_II_closed 
	}
///////////////////////////////////////////////////////////
	state A12_switch_II_closed {

		option -e;
		entry {
			EXP_update_report(DA12S2OFF);
		}
		
		when (EXP_FAIL_COND != STOK) {

		} state  clearance_faillures

		when (EXP_W29_STS != DA12S2OFF) {			

		} state watchman_29_pressed
	}
///////////////////////////////////////////////////////////
	state watchman_29_pressed {

		option -e;
		entry {
			EXP_update_report(B29OFF);
		}
    		
		when (EXP_FAIL_COND != STOK) {

		} state  clearance_faillures
			
		when (!EXP_W29_STS) {

			EXP_status();
		} state vault_cleared
   
		when (EXP_W29_STS != B29OFF) {
            
		} state A12_switch_I_closed  
	} 
///////////////////////////////////////////////////////////////
  state vault_cleared {
		option -e;
		entry {
			printf("%sEXPERIMENTAL VAULT IN CLEARED STATE%s\n",CLR,DEF);
		} 
		when (EXP_VC != STOK) {

		} state paniq_faillure
	}
///////////////////////////////////////////////////   
  state paniq_faillure {

		when (EXP_VC != EXPPNK) {

		} state clearance_faillures	
 
 		when () { // paniq button released?
			printf("EXP VAULT CLEARED FAILURE CONDITION: ");
			EXP_update_failed(EXPPNK); 

		} state recover_from_paniq	     
	}
////////////////////////////////////////////////////////////    
   	state recover_from_paniq {
		option -e;
		option -x;
		when (!EXP_PNK) { // paniq button released?
        // we only go to this state so we enter watchman_128b_pressed from one point(recover_from_faillure)
		} state recover_from_faillure  

		exit {
			exp_failed_rst = FALSE;
			exp_not_cleared = FALSE;
		}
	}
//////////////////////////////////////////////////////////////////
	state clearance_faillures { 			/* FAIL CONDITIONS*/
		
		option -e;
		option -x;
		entry {
			printf("EXP CLEARANCE FAILURE CONDITION: ");
			exp_failed_rst = FALSE;
			exp_not_cleared = FALSE;
			EXP_OLD_FAIL_COND = EXP_FAIL_COND;
			EXP_update_failed(EXP_FAIL_COND); 
		}
   
		when () {
		
		} state recover_from_faillure  	
	}
//////////////////////////////////////////////////////////
	state recover_from_faillure {
  
		when (!EXP_FAIL_COND) {
			printf("%sEXP RECOVERING FROM FAILLURE : ENTERING W26 STATE%s\n",OK,DEF);
		} state  watchman_26_pressed
   
		when (EXP_FAIL_COND != EXP_OLD_FAIL_COND) {

		} state  clearance_faillures
	} 
}
//////////////////////////////////////////////////////////////////////
void initVault(){
	//EXP_INIT = TRUE;
    EXP_RST_OUTS  = TRUE;
    EXP_OLD_FAIL_COND = EXP_FAIL_COND;
	not_cleared(EXP_CLR_STATS);
	report_error(EXP_INTLCK_STATS, 0);
    pvPut(EXP_RST_OUTS, SYNC);
	//pvPut(EXP_INIT, SYNC);
	pvPut(EXP_CLR_STATS, SYNC);
	pvPut(EXP_INTLCK_STATS, SYNC);
}

////////////////////////////////////////////////////////////////////////
void resetVault(){
	not_cleared(EXP_CLR_STATS);
	pvPut(EXP_CLR_STATS, SYNC);
}
////////////////////////////////////////////////////////////////////////
void EXP_update_failed(short report)
{
	clear_failed(EXP_CLR_STATS);
	pvPut(EXP_CLR_STATS, SYNC);
	report_error(EXP_INTLCK_STATS, report);
	pvPut(EXP_INTLCK_STATS, SYNC);
	printf("%s%s%s\n",ERROR,EXP_INTLCK_STATS,DEF);
}
/////////////////////////////////////////////////////////////////////////
void EXP_update_report(short intlck) {
	report_error(EXP_INTLCK_STATS, intlck);
	pvPut(EXP_INTLCK_STATS, SYNC);
}
////////////////////////////////////////////////////////////////////////
void EXP_status()
{  
	cleared(EXP_CLR_STATS);
	pvPut(EXP_CLR_STATS, SYNC); 		
	report_error(EXP_INTLCK_STATS, 0);
	pvPut(EXP_INTLCK_STATS, SYNC);
}
///////////////////////////////////////////////////////////
void EXP_clear_underway()
{  
	clear_underway(EXP_CLR_STATS);
	pvPut(EXP_CLR_STATS, SYNC); 		
}

//////////////////////////////////////////////////////////
%{

inline void cleared(string vault_status) {   
    strcpy(vault_status, mes_array[1]); // Area cleared  
}
////////////////////////////////////////////////
inline void not_cleared(string vault_status) {  
   strcpy(vault_status, mes_array[2]); // Area not cleared    
}
///////////////////////////////////////////////
inline void clear_underway(string vault_status) { 
   strcpy(vault_status, mes_array[3]);  // Area clearance underway    
}
//////////////////////////////////////////////
inline void clear_failed(string vault_status) { 
   strcpy(vault_status, mes_array[5]); // Area clearance fail   
}
////////////////////////////////////////////////
inline void report_error(string vault_interlock, short intlock)
{
   strcpy(vault_interlock, mes_array[intlock]);
}
	
}%
