program ssccabClearanceSNC

%{
#include "vcs_var_mes.h" // define this here so C functions are seen
	
#define	STOK       	0
#define FAIL		-1
#define	G5S1OFF		9
#define	G5S2OFF		10
#define WFVC		55
#define B16ON		12
#define B17OFF		11
#define SSCCABPNK	15 
}%
/* Declare seq variables*/
short SSCCAB_VC;   
short SSCCAB_W16_STS;
short SSCCAB_W17_STS;
short SSCCAB_RST_OUTS;
short SSCCAB_FAIL_COND;
short SSCCAB_PNK;
string SSCCAB_CLR_STATS; 
string SSCCAB_INTLCK_STATS;

// CONTROL FLAGS
short SSCCAB_OLD_FAIL_COND;
short SSCCAB_FAILED_RST = FALSE;

/* Associate SNL variables with epics output pv's*/
assign	SSCCAB_RST_OUTS		to	"{SYS}:RST-SSCCAB.PROC"; 
assign	SSCCAB_CLR_STATS	to	"{SYS}:SSCCAB-CLR-STATS"; 
assign	SSCCAB_INTLCK_STATS to	"{SYS}:SSCCAB-INTLCK-STATS"; 
/* Associate SNL variables with epics input pv's*/
assign 	SSCCAB_VC 			to 	"{SYS}:SSCCAB-VC"; 
assign 	SSCCAB_W16_STS 		to  "{SYS}:SSC-W16-STS";   
assign 	SSCCAB_W17_STS 		to  "{SYS}:SSC-W17-STS";
assign	SSCCAB_FAIL_COND	to	"{SYS}:SSCCAB-FAIL-COND";
assign	SSCCAB_PNK			to	"{SYS}:SSCCAB-PNK";

// monitor changes
monitor	SSCCAB_VC;
monitor SSCCAB_W16_STS;   
monitor SSCCAB_W17_STS;
monitor	SSCCAB_FAIL_COND;
monitor	SSCCAB_PNK;

ss SSCCAB_clearance_status {
    state init {
		  when (delay(1)) {
			  initVault();
			  printf("\n%sSSC CABLE WAY VAULT VAULT INITIALISATION COMPLETED%s\n",OK,DEF);
		  } state watchman_16_pressed	
    }
//////////////////////////////////////////////////////////

	state watchman_16_pressed {

		when (SSCCAB_FAIL_COND != STOK) {
			SSCCAB_OLD_FAIL_COND = SSCCAB_FAIL_COND;
		} state  clearance_faillures
        
		/*when (SSCCAB_W16_STS == WFVC) {

		} state  clearance_pending */      
			
		when (SSCCAB_W16_STS == B16ON) {
			SSCCAB_clear_underway();
			SSCCAB_update_report(B16ON);
		} state watchman_16_released
	}
//////////////////////////////////////////////////////////
/*	state clearance_pending {
    option -e;
		option -x;
   
		entry {
            resetVault();
            SSCCAB_update_report(WFVC);
		}
   
		when (SSCCAB_W16_STS != WFVC) {

		} state watchman_16_pressed  		

	}*/
//////////////////////////////////////////////////////////
	state watchman_16_released {
		
		when (SSCCAB_FAIL_COND != STOK) {

		} state  clearance_faillures
			
		when (SSCCAB_W16_STS != B16ON) {
			
		} state g5_switch_I_closed
	}
//////////////////////////////////////////////////////////
	state g5_switch_I_closed {
 
		option -e;

		entry {
		  SSCCAB_update_report(G5S1OFF);
		}  
		
		when (SSCCAB_FAIL_COND != STOK) {

		} state  clearance_faillures
		
		when (SSCCAB_W17_STS != G5S1OFF) {			

		} state  g5_switch_II_closed
	}
//////////////////////////////////////////////////////////
	state g5_switch_II_closed {
 
		option -e;

		entry {
		  SSCCAB_update_report(G5S2OFF);
		}  
		
		when (SSCCAB_FAIL_COND != STOK) {

		} state  clearance_faillures
		// previous switch might have opened up
		when (SSCCAB_W17_STS == G5S1OFF) {			

		} state  g5_switch_I_closed
        
        
		when (SSCCAB_W17_STS != G5S2OFF) {			

		} state  watchman_17_pressed
	}
///////////////////////////////////////////////////////////
	state watchman_17_pressed {

		option -e;
		entry {
			SSCCAB_update_report(B17OFF);
		}
    		
		when (SSCCAB_FAIL_COND != STOK) {

		} state  clearance_faillures
			
		when (SSCCAB_W17_STS == STOK) {

			SSCCAB_status();
		} state vault_cleared
   
		when (SSCCAB_W17_STS != B17OFF) {
            
		} state g5_switch_I_closed
	} 
///////////////////////////////////////////////////////////////
  state vault_cleared {
		option -e;
		entry {
			printf("%sSSC CABLE VAULT IN CLEARED STATE%s\n",CLR,DEF);
		} 
		when (SSCCAB_VC != STOK) {

		} state paniq_faillure
	}
///////////////////////////////////////////////////   
  state paniq_faillure {

		when (SSCCAB_VC != SSCCABPNK) {

		} state clearance_faillures	
 
 		when () { // paniq button released?
            printf("SSC CABLE VAULT CLEARED FAILURE CONDITION: ");
            SSCCAB_update_failed(SSCCABPNK); 

		} state recover_from_paniq	     
	}
////////////////////////////////////////////////////////////    
   	state recover_from_paniq {
		option -e;
		option -x;
		when (!SSCCAB_PNK) { // paniq button released?
        // we only go to this state so we enter watchman_147_pressed from one point(recover_from_faillure)
		} state recover_from_faillure  

		exit {
            SSCCAB_FAILED_RST = FALSE;
		}
	}
//////////////////////////////////////////////////////////////////
	state clearance_faillures { 			/* FAIL CONDITIONS*/
		
		option -e;
		option -x;
		entry {
		    printf("SSC CABLE CLEARANCE FAILURE CONDITION: ");
			SSCCAB_FAILED_RST = FALSE;
			SSCCAB_OLD_FAIL_COND = SSCCAB_FAIL_COND;
            SSCCAB_update_failed(SSCCAB_FAIL_COND == FAIL ? STOK : SSCCAB_FAIL_COND); // we cannot index -1(FAIL)
		}
   
		when () {
		
		} state recover_from_faillure  	
	}
//////////////////////////////////////////////////////////
	state recover_from_faillure {
  
		when (!SSCCAB_FAIL_COND) {
            printf("%sSSC GROUND-FLOOR RECOVERING FROM FAILLURE : ENTERING W9 STATE%s\n",OK,DEF);
		} state  watchman_16_pressed
   
		when (SSCCAB_FAIL_COND != SSCCAB_OLD_FAIL_COND) {

		} state  clearance_faillures
	} 
}
//////////////////////////////////////////////////////////////////////
void initVault(){
	//SSCCAB_INIT = TRUE;
    SSCCAB_RST_OUTS  = TRUE;
    SSCCAB_OLD_FAIL_COND = SSCCAB_FAIL_COND;
	not_cleared(SSCCAB_CLR_STATS);
	report_error(SSCCAB_INTLCK_STATS, 0);
    pvPut(SSCCAB_RST_OUTS, SYNC);
	//pvPut(SSCCAB_INIT, SYNC);
	pvPut(SSCCAB_CLR_STATS, SYNC);
	pvPut(SSCCAB_INTLCK_STATS, SYNC);
}

////////////////////////////////////////////////////////////////////////
void resetVault(){
	not_cleared(SSCCAB_CLR_STATS);
	pvPut(SSCCAB_CLR_STATS, SYNC);
}
////////////////////////////////////////////////////////////////////////
void SSCCAB_update_failed(short report)
{
	clear_failed(SSCCAB_CLR_STATS);
	pvPut(SSCCAB_CLR_STATS, SYNC);
	report_error(SSCCAB_INTLCK_STATS, report);
	pvPut(SSCCAB_INTLCK_STATS, SYNC);
	printf("%s%s%s\n",ERROR,SSCCAB_INTLCK_STATS,DEF);
}
/////////////////////////////////////////////////////////////////////////
void SSCCAB_update_report(short intlck) {
	report_error(SSCCAB_INTLCK_STATS, intlck);
	pvPut(SSCCAB_INTLCK_STATS, SYNC);
}
////////////////////////////////////////////////////////////////////////
void SSCCAB_status()
{  
	cleared(SSCCAB_CLR_STATS);
	pvPut(SSCCAB_CLR_STATS, SYNC); 		
	report_error(SSCCAB_INTLCK_STATS, 0);
	pvPut(SSCCAB_INTLCK_STATS, SYNC);
}
///////////////////////////////////////////////////////////
void SSCCAB_clear_underway()
{  
	clear_underway(SSCCAB_CLR_STATS);
	pvPut(SSCCAB_CLR_STATS, SYNC); 		
}
/**********************************************************/

