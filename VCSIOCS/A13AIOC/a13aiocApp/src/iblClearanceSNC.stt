program iblClearanceSNC

%{
#include "vcs_var_mes.h" // define this here so C functions are seen
	
#define	STOK       0
#define FAIL		-1 	
#define	DA13S1OFF	91	
#define	DA13S2OFF	92	
#define B9ON        87
#define B8OFF       88
#define B8ON  		89
#define B7OFF		93   
#define IBLPNK		95 
#define WFVC		194
}%
/* Declare seq variables*/
short IBL_INIT; 
short IBL_VC;   
short IBL_W9_STS;
short IBL_W8_STS;
short IBL_W7_STS;
short IBL_RST_OUTS;
short IBL_FAIL_COND;
short IBL_PNK;
string IBL_CLR_STATS; 
string IBL_INTLCK_STATS;

short IBL_OLD_FAIL_COND;
short IBL_FAILED_RST = FALSE;

/* Associate SNL variables with epics output pv's*/
assign	IBL_RST_OUTS		to	"{SYS}:RST-IBL.PROC"; 
assign	IBL_CLR_STATS		to	"{SYS}:IBL-CLR-STATS"; 
assign	IBL_INTLCK_STATS	to	"{SYS}:IBL-INTLCK-STATS"; 
/* Associate SNL variables with epics input pv's*/
assign 	IBL_VC 				to 	"{SYS}:IBL-VC"; 

assign 	IBL_W9_STS 			 to "{SYS}:IBL-W9-STS"; 
assign 	IBL_W8_STS 			 to "{SYS}:IBL-W8-STS";   
assign 	IBL_W7_STS 			 to "{SYS}:IBL-W7-STS";
assign	IBL_FAIL_COND		 to	"{SYS}:IBL-FAIL-COND";
assign	IBL_PNK		       	 to	"{SYS}:IBL-PNK";

monitor	IBL_VC;
monitor IBL_W9_STS; 
monitor IBL_W8_STS;   
monitor IBL_W7_STS;
monitor	IBL_FAIL_COND;
monitor	IBL_PNK;

ss IBL_clearance_status {
    state init {
		  when (delay(1)) {
			  initVault();
			  printf("%sISOTOPE BEAM LINE INITIALISATION COMPLETED%s\n",OK,DEF);
		  } state watchman_9_pressed	
    }
//////////////////////////////////////////////////////////

	state watchman_9_pressed {

		when (IBL_FAIL_COND != STOK) {
			IBL_OLD_FAIL_COND = IBL_FAIL_COND;
		} state  clearance_faillures
        
		when (IBL_W9_STS == WFVC) {

		} state  clearance_pending     
			
		when (IBL_W9_STS == B9ON) {
			IBL_clear_underway();
			IBL_update_report(B9ON);
		} state watchman_9_released
	}
//////////////////////////////////////////////////////////
	state clearance_pending {
		option -e;
		option -x;
   
		entry {
			/*resetVault();
			IBL_update_report(WFVC);*/
		}
   
		when (IBL_W9_STS != WFVC) {

		} state watchman_9_pressed  		

	}
//////////////////////////////////////////////////////////
	state watchman_9_released {
		
		when (IBL_FAIL_COND != STOK) {

		} state  clearance_faillures
			
		when (IBL_W9_STS != B9ON) {
			IBL_update_report(B8OFF);
		} state watchman_8_pressed
	}
//////////////////////////////////////////////////////////
	state watchman_8_pressed {

		when (IBL_FAIL_COND != STOK) {

		} state   clearance_faillures
		
		
		when (IBL_W8_STS == B8ON) {
			IBL_update_report(B8ON);
		} state watchman_8_released
	}
//////////////////////////////////////////////////////////
	state watchman_8_released {
		
		when (IBL_FAIL_COND != STOK) {

		} state  clearance_faillures
			
		when (IBL_W8_STS != B8ON) {
;
		} state a13_switch_I_closed
		
	}
///////////////////////////////////////////////////////////
	state a13_switch_I_closed {
 
		option -e;

		entry {
		  IBL_update_report(DA13S1OFF);
		}  
		
		when (IBL_FAIL_COND != STOK) {

		} state  clearance_faillures
		
		when (IBL_W7_STS != DA13S1OFF) {			

		} state a13_switch_II_closed 
	}
///////////////////////////////////////////////////////////
	state a13_switch_II_closed {

		option -e;
		entry {
			IBL_update_report(DA13S2OFF);
		}
		
		when (IBL_FAIL_COND != STOK) {

		} state  clearance_faillures

		when (IBL_W7_STS != DA13S2OFF) {			

		} state watchman_7_pressed
	}
///////////////////////////////////////////////////////////
	state watchman_7_pressed {

		option -e;
		entry {
			IBL_update_report(B7OFF);
		}
    		
		when (IBL_FAIL_COND != STOK) {

		} state  clearance_faillures
			
		when (!IBL_W7_STS) {

			IBL_status();
		} state vault_cleared
   
		when (IBL_W7_STS != B7OFF) {
            
		} state a13_switch_I_closed  
	} 
///////////////////////////////////////////////////////////////
  state vault_cleared {
		option -e;
		entry {
			printf("%sISOTOPE BEAM LINE IN CLEARED STATE%s\n",CLR,DEF);
		} 
		when (IBL_VC != STOK) {

		} state paniq_faillure
	}
///////////////////////////////////////////////////   
  state paniq_faillure {

		when (IBL_VC != IBLPNK) {

		} state clearance_faillures	
 
 		when () { // paniq button released?
			printf("IBL VAULT CLEARED FAILURE CONDITION: ");
			IBL_update_failed(IBLPNK); 
		} state recover_from_paniq	     
	}
////////////////////////////////////////////////////////////    
   	state recover_from_paniq {
		option -e;
		option -x;
		when (!IBL_PNK) { // paniq button released?
        // we only go to this state so we enter watchman_18_pressed from one point(recover_from_faillure)
		} state recover_from_faillure  

		exit {
            IBL_FAILED_RST = FALSE;
		}
	}
//////////////////////////////////////////////////////////////////
	state clearance_faillures { 			/* FAIL CONDITIONS*/
		
		option -e;
		option -x;
		entry {
		printf("IBL CLEARANCE FAILURE CONDITION: ");
			IBL_FAILED_RST = FALSE;
			IBL_OLD_FAIL_COND = IBL_FAIL_COND;
			IBL_update_failed(IBL_FAIL_COND == FAIL ? STOK : IBL_FAIL_COND); // we cannot index -1(FAIL)
		}
   
		when () {
		
		} state recover_from_faillure  	
	}
//////////////////////////////////////////////////////////
	state recover_from_faillure {
  
		when (!IBL_FAIL_COND) {
      printf("%sIBL RECOVERING FROM FAILLURE : ENTERING W9 STATE%s\n",OK,DEF);
		} state  watchman_9_pressed
   
		when (IBL_FAIL_COND != IBL_OLD_FAIL_COND) {

		} state  clearance_faillures
	} 
}
//////////////////////////////////////////////////////////////////////
void initVault(){
    IBL_RST_OUTS  = TRUE;
    IBL_OLD_FAIL_COND = IBL_FAIL_COND;
	not_cleared(IBL_CLR_STATS);
	report_error(IBL_INTLCK_STATS, 0);
    pvPut(IBL_RST_OUTS, SYNC);
	pvPut(IBL_CLR_STATS, SYNC);
	pvPut(IBL_INTLCK_STATS, SYNC);
}

////////////////////////////////////////////////////////////////////////
void resetVault(){
	not_cleared(IBL_CLR_STATS);
	pvPut(IBL_CLR_STATS, SYNC);
}
////////////////////////////////////////////////////////////////////////
void IBL_update_failed(short report)
{
	clear_failed(IBL_CLR_STATS);
	pvPut(IBL_CLR_STATS, SYNC);
	report_error(IBL_INTLCK_STATS, report);
	pvPut(IBL_INTLCK_STATS, SYNC);
	printf("%s%s%s\n",ERROR,IBL_INTLCK_STATS,DEF);
}
/////////////////////////////////////////////////////////////////////////
void IBL_update_report(short intlck) {
	report_error(IBL_INTLCK_STATS, intlck);
	pvPut(IBL_INTLCK_STATS, SYNC);
}
////////////////////////////////////////////////////////////////////////
void IBL_status()
{  
	cleared(IBL_CLR_STATS);
	pvPut(IBL_CLR_STATS, SYNC); 		
	report_error(IBL_INTLCK_STATS, 0);
	pvPut(IBL_INTLCK_STATS, SYNC);
}
///////////////////////////////////////////////////////////
void IBL_clear_underway()
{  
	clear_underway(IBL_CLR_STATS);
	pvPut(IBL_CLR_STATS, SYNC); 		
}
/**********************************************************/

