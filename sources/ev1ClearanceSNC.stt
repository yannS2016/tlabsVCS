program ev1ClearanceSNC
%{
/**********************************************************/
	#include "vcs_var_mes.h"
/**********************************************************/
	#define	VC       	0
	#define TOUT		5
	#define	RA6ON       147
	#define	RA7ON		148
	#define EV1PNK      134
	#define	DA6ON       101
	#define	B19ON       105
	#define	B18ON       187
	#define	B18OFF      102
	#define DA6S1ON		103 
	#define DA6S2ON		104
}%
/* Declare seq variables*/
short EV1_INIT; 
short EV1_SEL_STAGE;

short EV1_VC; 
short EV1_VNCS1;   
short EV1_VNCS2;    
string EV1_CLR_STATS; 
string EV1_INTLCK_STATS;
/* Associate SNL variables with epics output pv's*/
assign	EV1_CLR_STATS		to	"{SYS}:EV1-CLR-STATS"; 
assign	EV1_INTLCK_STATS	to	"{SYS}:EV1-INTLCK-STATS"; 
/* Associate SNL variables with epics input pv's*/
assign 	EV1_VC 				to 	"{SYS}:EV1-VC"; 
assign 	EV1_VNCS1 			to  "{SYS}:EV1-VNCS1";   
assign 	EV1_VNCS2 			to 	"{SYS}:EV1-VNCS2";
assign 	EV1_INIT 			to 	"{SYS}:EV1-INIT";
assign	EV1_SEL_STAGE		to	"{SYS}:EV1-SEL-STAGE";

monitor	EV1_VC;
monitor	EV1_VNCS1;
monitor	EV1_VNCS2;
monitor	EV1_SEL_STAGE;

ss ev1_clearance_status {
    state init {
		when (delay(4)) {
			initVault();
			printf("EV1 INITIALISATION COMPLETED\n");
		} state vault_nc_stage_1	
    }
	/*VAULT CLEARED STATE*/
    state vault_cleared {
		option -e;
		entry {
			printf("EV1 IN CLEARED STATE\n");
		} 

		when (EV1_VC == RA6ON) {
			ev1_update_failed(RA6ON);
			printf("The roof is open\n");

		} state vault_nc_stage_1
		
		
		when (EV1_VC == RA7ON) {
			ev1_update_failed(RA7ON);
			printf("Experimental vault 2 roof is open\n");
		} state vault_nc_stage_1
		
		
		when (EV1_VC == DA6ON) {
			ev1_update_failed(DA6ON);
			printf("Door A6 was opened\n");
		} state vault_nc_stage_1


		when (EV1_VC == EV1PNK) {
			ev1_update_failed(EV1PNK);
			printf("Panic button 18 was pressed\n");
		} state vault_nc_stage_1
	}
	
	/*VAULT NOT CLEARED STAGE 1*/
	state vault_nc_stage_1 {

		when (EV1_SEL_STAGE == 3) {
			ev1_clear_underway();
			/*printf("CLEAR UNDERWAY: STAGE 2\n");*/
		} state vault_nc_stage_2


		when (EV1_VNCS1 == RA6ON) {
			ev1_update_failed(RA6ON);
			printf("The roof is open\n");
		} state vault_nc_stage_1


		when (EV1_VNCS1 == RA7ON) {
			ev1_update_failed(RA7ON);
			printf("Experimental vault 2 roof is open\n");
		} state vault_nc_stage_1
		
		
		when(EV1_VNCS1 == B18ON){
			ev1_update_report(B18ON);		
			/*printf("Waiting for Vault Clearance\n");*/
		}state vault_nc_stage_1
	}
	
	/*VAULT NOT CLEARED STAGE 2*/
	state vault_nc_stage_2 {
		
		when (EV1_SEL_STAGE == 1) {
			ev1_status();
		} state vault_cleared


		when (EV1_VNCS2 == B18OFF) {
			ev1_update_report(B18OFF);
			printf("Watchman 18 must be released\n");
		} state vault_nc_stage_2
		
		
		when (EV1_VNCS2 == RA6ON) {
			ev1_update_failed(RA6ON);
			printf("The roof is open\n");
		} state vault_nc_stage_1
		
		
		when (EV1_VNCS2 == RA7ON) {
			ev1_update_failed(RA6ON);
			printf("Experimental vault 2 roof is open\n");
		} state vault_nc_stage_1
		
		when (EV1_VNCS2 == TOUT) {
			ev1_update_failed(TOUT);
			printf("TIME OUT ERROR: RELEASE ALL WATCHMEN\n");
		} state vault_nc_stage_1
		
		
		when (EV1_VNCS2 == DA6S1ON) {
			ev1_update_report(DA6S1ON);
			printf("Door A6 switch 1 is open\n");
		} state vault_nc_stage_2
		
		
		when (EV1_VNCS2 == DA6S2ON) {
			ev1_update_report(DA6S2ON);
			printf("Door A6 switch 2 is open\n");
		} state vault_nc_stage_2
		
		
		when (EV1_VNCS2 == B19ON) {
			ev1_update_report(B19ON);
			printf("Watchman 19 must be activated\n");
		} state vault_nc_stage_2

	}	
}

void initVault(){
	EV1_INIT = TRUE;
	not_cleared(EV1_CLR_STATS);
	report_error(EV1_INTLCK_STATS, 54);
	pvPut(EV1_INIT, SYNC);
	pvPut(EV1_CLR_STATS, SYNC);
	pvPut(EV1_INTLCK_STATS, SYNC);
}

////////////////////////////////////////////////////////////////////////
void ev1_update_failed(short report)
{
	clear_failed(EV1_CLR_STATS);
	pvPut(EV1_CLR_STATS, SYNC);
	report_error(EV1_INTLCK_STATS, report);
	pvPut(EV1_INTLCK_STATS, SYNC);
}
/////////////////////////////////////////////////////////////////////////
void ev1_update_report(short intlck) {
	report_error(EV1_INTLCK_STATS, intlck);
	pvPut(EV1_INTLCK_STATS, SYNC);
}
////////////////////////////////////////////////////////////////////////
void ev1_status()
{  
	cleared(EV1_CLR_STATS);
	pvPut(EV1_CLR_STATS, SYNC); 		
	report_error(EV1_INTLCK_STATS, 54);
	pvPut(EV1_INTLCK_STATS, SYNC);
}
///////////////////////////////////////////////////////////
void ev1_clear_underway()
{  
	clear_underway(EV1_CLR_STATS);
	pvPut(EV1_CLR_STATS, SYNC); 		
}
/**********************************************************/
%{

inline void cleared(string vault_status) {   
    strcpy(vault_status, mes_array[0]); // Area cleared  
}
////////////////////////////////////////////////
inline void not_cleared(string vault_status) {  
   strcpy(vault_status, mes_array[1]); // Area not cleared    
}
///////////////////////////////////////////////
inline void clear_underway(string vault_status) { 
   strcpy(vault_status, mes_array[2]);  // Area clearance underway    
}
//////////////////////////////////////////////
inline void clear_failed(string vault_status) { 
   strcpy(vault_status, mes_array[4]); // Area clearance fail   
}
////////////////////////////////////////////////
inline void report_error(string vault_interlock, short intlock)
{
   strcpy(vault_interlock, mes_array[intlock]);
}
	
}%
